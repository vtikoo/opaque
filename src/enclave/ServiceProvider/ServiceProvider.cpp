#include <openssl/pem.h>
#include <cassert>
#include <fstream>
#include <iomanip>
//#include <sgx_tcrypto.h>

#include <iostream>
#include <memory>

#include "ecp.h"
#include "ias_ra.h"
#include "iasrequest.h"
#include "crypto.h"
#include "base64.h"
#include "json.hpp"

#include <openenclave/host_verify.h>

#include "ServiceProvider.h"

// Your 16-byte Service Provider ID (SPID), assigned by Intel.
const uint8_t spid[] = {0xA4,0x62,0x09,0x2E,0x1B,0x59,0x26,0xDF,0x44,0x69,0xD5,0x61,0xE2,0x54,0xB0,0x1E};

// The EPID security policy you chose (linkable -> true, unlinkable -> false).
const bool linkable_signature = false;

ServiceProvider service_provider(
  std::string(reinterpret_cast<const char *>(spid), sizeof(spid)),
  linkable_signature,
  // Whether to use the production IAS URL rather than the testing URL.
  false);

void lc_check(lc_status_t ret) {
  if (ret != LC_SUCCESS) {
    std::string error;
    switch (ret) {
    case LC_ERROR_UNEXPECTED:
      error = "Unexpected error";
      break;
    case LC_ERROR_INVALID_PARAMETER:
      error = "Invalid parameter";
      break;
    case LC_ERROR_OUT_OF_MEMORY:
      error = "Out of memory";
      break;
    default:
      error = "Unknown error";
    }

    throw std::runtime_error(
      std::string("Service provider crypto failure: ")
      + error);
  }
}


void ServiceProvider::load_private_key(const std::string &filename) {
  FILE *private_key_file = fopen(filename.c_str(), "r");
  if (private_key_file == nullptr) {
    throw std::runtime_error(
      std::string("Error: Private key file '")
      + filename
      + std::string("' does not exist. Set $PRIVATE_KEY_PATH to the file generated by "
                    "openssl ecparam -genkey, probably called ${OPAQUE_HOME}/private_key.pem."));
  }

  EVP_PKEY *pkey = PEM_read_PrivateKey(private_key_file, NULL, NULL, NULL);
  if (pkey == nullptr) {
    throw std::runtime_error(
      "Unable to read private key from '"
      + filename
      + std::string("'."));
  }

  EC_KEY *ec_key = EVP_PKEY_get1_EC_KEY(pkey);
  if (!ec_key) {
    throw std::runtime_error("EVP_PKEY_get1_EC_KEY failed.");
  }

  const EC_GROUP *group = EC_KEY_get0_group(ec_key);
  const EC_POINT *point = EC_KEY_get0_public_key(ec_key);

  BIGNUM *x_ec = BN_new();
  BIGNUM *y_ec = BN_new();
  if (EC_POINT_get_affine_coordinates_GFp(group, point, x_ec, y_ec, nullptr) == 0) {
    throw std::runtime_error("EC_POINT_get_affine_coordinates_GFp failed.");
  }

  const BIGNUM *priv_bn = EC_KEY_get0_private_key(ec_key);

  // Store the public and private keys in binary format
  std::unique_ptr<uint8_t> x_(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> y_(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> r_(new uint8_t[LC_ECP256_KEY_SIZE]);

  std::unique_ptr<uint8_t> x(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> y(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> r(new uint8_t[LC_ECP256_KEY_SIZE]);

  BN_bn2bin(x_ec, x_.get());
  BN_bn2bin(y_ec, y_.get());
  BN_bn2bin(priv_bn, r_.get());

  // reverse x_, y_, r_
  for (uint32_t i = 0; i < LC_ECP256_KEY_SIZE; i++) {
    x.get()[i] = x_.get()[LC_ECP256_KEY_SIZE-i-1];
    y.get()[i] = y_.get()[LC_ECP256_KEY_SIZE-i-1];
    r.get()[i] = r_.get()[LC_ECP256_KEY_SIZE-i-1];
  }

  // Store public and private keys
  memcpy(sp_pub_key.gx, x.get(), LC_ECP256_KEY_SIZE);
  memcpy(sp_pub_key.gy, y.get(), LC_ECP256_KEY_SIZE);
  memcpy(sp_priv_key.r, r.get(), LC_ECP256_KEY_SIZE);

  // Clean up
  BN_free(x_ec);
  BN_free(y_ec);
  EC_KEY_free(ec_key);
  EVP_PKEY_free(pkey);
}

void ServiceProvider::set_shared_key(const uint8_t *shared_key) {
  memcpy(this->shared_key, shared_key, LC_AESGCM_KEY_SIZE);
}

void ServiceProvider::export_public_key_code(const std::string &filename) {
  std::ofstream file(filename.c_str());

  file << "#include \"key.h\"\n";
  file << "const sgx_ec256_public_t g_sp_pub_key = {\n";

  file << "{";
  for (uint32_t i = 0; i < LC_ECP256_KEY_SIZE; ++i) {
    file << "0x" << std::hex << std::setfill('0') << std::setw(4) << int(sp_pub_key.gx[i]);
    if (i < LC_ECP256_KEY_SIZE - 1) {
      file << ", ";
    }
  }
  file << "},\n";

  file << "{";
  for (uint32_t i = 0; i < LC_ECP256_KEY_SIZE; ++i) {
    file << "0x" << std::hex << std::setfill('0') << std::setw(4) << int(sp_pub_key.gy[i]);
    if (i < LC_ECP256_KEY_SIZE - 1) {
      file << ", ";
    }
  }
  file << "}\n";

  file << "};\n";
  file.close();
}

std::unique_ptr<oe_msg2_t> ServiceProvider::process_msg1(
  oe_msg1_t *msg1, uint32_t *msg2_size) {

  //verify report
  oe_report_t parsed_report;
  oe_result_t result = OE_FAILURE;
  std::unique_ptr<oe_msg2_t> msg2(new oe_msg2_t);
  int ret;

  unsigned char encrypted_sharedkey[OE_SHARED_KEY_CIPHERTEXT_SIZE];
  size_t encrypted_sharedkey_size = sizeof(encrypted_sharedkey);

  EVP_PKEY* pkey = buffer_to_public_key((char*)msg1->public_key, -1);
  if (pkey == nullptr) {
    throw std::runtime_error("buffer_to_public_key failed.");
  }

  result = oe_verify_remote_report(msg1->report, msg1->report_size, NULL, 0, &parsed_report);
  if (result != OE_OK) {
    throw std::runtime_error(
      std::string("oe_verify_remote_report: ")
      + oe_result_str(result));
  }

  //TODO - other verification

  // Encrypt shared key
  ret = public_encrypt(pkey, this->shared_key, LC_AESGCM_KEY_SIZE, encrypted_sharedkey, &encrypted_sharedkey_size);
  if (ret == 0) {
    throw std::runtime_error(std::string("public_encrypt: buffer too small"));
  }
  else if (ret < 0) {
    throw std::runtime_error(std::string("public_encrypt failed"));
  }

  // Prepare msg2
  memcpy_s(msg2->shared_key_ciphertext, OE_SHARED_KEY_CIPHERTEXT_SIZE, encrypted_sharedkey, encrypted_sharedkey_size);
  *msg2_size = sizeof(oe_msg2_t);

  // clean up
  EVP_PKEY_free(pkey);

  return msg2;
}
